# springbatch


`@EnableBatchProcessing` 
- 스프링 배치를 활성화하기 위해 사용되는 어노테이션
- 빈으로 등록된 Job을 검색하여 실행 되도록 함

    1. SimpleBatchConfiguration.class 실행
    2. BatchConfigurerConfiguration.class 실행
        - BasicBatchConfigurer
        - JpaBatchConfigurer
    3. BatchAutoConfiguration.class 실행

### 프로젝트 구성 순서

1. `@Configuration` 선언
2. JobBuilderFactory
   - JobBuilder 생성 -> Job 생성
3. StepBuilderFactory
   - StepBuilder 생성 -> Step 생성
4. Job
5. Step
6. tasklet
   - 비즈니스 로직이 포함
   - 
7. Job 구동 >> Step 실행 >> Tasklet 실행

### DB 스키마 생성
여러 배치 관련 정보들을 저장할 수 있는 스키마를 제공한다. 

![스프링 배치 메타 데이터](./readmeImages/meta-data-erd.png)




##### Docker에 MySQL 설치

1. wsl2로 도커 설치
2. window terminals를 활용해 컨테이너 생성
```shell
# 설치 확인(버전 확인)
docker -v
# MySQL 도커 이미지 다운
docker pull mysql
# 다운로드한 Docker Image 확인
docker images 
# 컨테이너 생성 및 실행
docker run -p 3306:3306 --name springboot-mysql -e MYSQL_ROOT_PASSWORD=0000 -e MYSQL_DATABASE=springbatch -e MYSQL_USER=yooyeon -e MYSQL_PASSWORD=yooyeon1234@ -d mysql
# docker container 리스트
docker ps -a
# 컨테이너 삭제
docker rm '컨테이너 이름'
또는
docker rm '컨테이너 id'
```

- 기타 명령어

```shell
# 컨테이너 시작
docker start springboot-mysql

# 컨테이너 중지
docker stop springboot-mysql

# 컨테이너 재시작
docker restart springboot-mysql
```

3. 인텔리제이에서 컨테이너 실행
```shell
# 실행
docker start springboot-mysql

# 확인
docker ps
```


4. spring-batch-core 라이브러리에 org.springframework.batch.core/schema-mysql.sql에 메타데이터 테이블 생성 쿼리문이 담겨있다. 수동으로 생성하려면 다음 명령문을 실행하면 된다. 

```sql
-- Autogenerated: do not edit this file

CREATE TABLE BATCH_JOB_INSTANCE  (
	JOB_INSTANCE_ID BIGINT  NOT NULL PRIMARY KEY ,
	VERSION BIGINT ,
	JOB_NAME VARCHAR(100) NOT NULL,
	JOB_KEY VARCHAR(32) NOT NULL,
	constraint JOB_INST_UN unique (JOB_NAME, JOB_KEY)
) ENGINE=InnoDB;

CREATE TABLE BATCH_JOB_EXECUTION  (
	JOB_EXECUTION_ID BIGINT  NOT NULL PRIMARY KEY ,
	VERSION BIGINT  ,
	JOB_INSTANCE_ID BIGINT NOT NULL,
	CREATE_TIME DATETIME(6) NOT NULL,
	START_TIME DATETIME(6) DEFAULT NULL ,
	END_TIME DATETIME(6) DEFAULT NULL ,
	STATUS VARCHAR(10) ,
	EXIT_CODE VARCHAR(2500) ,
	EXIT_MESSAGE VARCHAR(2500) ,
	LAST_UPDATED DATETIME(6),
	JOB_CONFIGURATION_LOCATION VARCHAR(2500) NULL,
	constraint JOB_INST_EXEC_FK foreign key (JOB_INSTANCE_ID)
	references BATCH_JOB_INSTANCE(JOB_INSTANCE_ID)
) ENGINE=InnoDB;

CREATE TABLE BATCH_JOB_EXECUTION_PARAMS  (
	JOB_EXECUTION_ID BIGINT NOT NULL ,
	TYPE_CD VARCHAR(6) NOT NULL ,
	KEY_NAME VARCHAR(100) NOT NULL ,
	STRING_VAL VARCHAR(250) ,
	DATE_VAL DATETIME(6) DEFAULT NULL ,
	LONG_VAL BIGINT ,
	DOUBLE_VAL DOUBLE PRECISION ,
	IDENTIFYING CHAR(1) NOT NULL ,
	constraint JOB_EXEC_PARAMS_FK foreign key (JOB_EXECUTION_ID)
	references BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)
) ENGINE=InnoDB;

CREATE TABLE BATCH_STEP_EXECUTION  (
	STEP_EXECUTION_ID BIGINT  NOT NULL PRIMARY KEY ,
	VERSION BIGINT NOT NULL,
	STEP_NAME VARCHAR(100) NOT NULL,
	JOB_EXECUTION_ID BIGINT NOT NULL,
	START_TIME DATETIME(6) NOT NULL ,
	END_TIME DATETIME(6) DEFAULT NULL ,
	STATUS VARCHAR(10) ,
	COMMIT_COUNT BIGINT ,
	READ_COUNT BIGINT ,
	FILTER_COUNT BIGINT ,
	WRITE_COUNT BIGINT ,
	READ_SKIP_COUNT BIGINT ,
	WRITE_SKIP_COUNT BIGINT ,
	PROCESS_SKIP_COUNT BIGINT ,
	ROLLBACK_COUNT BIGINT ,
	EXIT_CODE VARCHAR(2500) ,
	EXIT_MESSAGE VARCHAR(2500) ,
	LAST_UPDATED DATETIME(6),
	constraint JOB_EXEC_STEP_FK foreign key (JOB_EXECUTION_ID)
	references BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)
) ENGINE=InnoDB;

CREATE TABLE BATCH_STEP_EXECUTION_CONTEXT  (
	STEP_EXECUTION_ID BIGINT NOT NULL PRIMARY KEY,
	SHORT_CONTEXT VARCHAR(2500) NOT NULL,
	SERIALIZED_CONTEXT TEXT ,
	constraint STEP_EXEC_CTX_FK foreign key (STEP_EXECUTION_ID)
	references BATCH_STEP_EXECUTION(STEP_EXECUTION_ID)
) ENGINE=InnoDB;

CREATE TABLE BATCH_JOB_EXECUTION_CONTEXT  (
	JOB_EXECUTION_ID BIGINT NOT NULL PRIMARY KEY,
	SHORT_CONTEXT VARCHAR(2500) NOT NULL,
	SERIALIZED_CONTEXT TEXT ,
	constraint JOB_EXEC_CTX_FK foreign key (JOB_EXECUTION_ID)
	references BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)
) ENGINE=InnoDB;

CREATE TABLE BATCH_STEP_EXECUTION_SEQ (
	ID BIGINT NOT NULL,
	UNIQUE_KEY CHAR(1) NOT NULL,
	constraint UNIQUE_KEY_UN unique (UNIQUE_KEY)
) ENGINE=InnoDB;

INSERT INTO BATCH_STEP_EXECUTION_SEQ (ID, UNIQUE_KEY) select * from (select 0 as ID, '0' as UNIQUE_KEY) as tmp where not exists(select * from BATCH_STEP_EXECUTION_SEQ);

CREATE TABLE BATCH_JOB_EXECUTION_SEQ (
	ID BIGINT NOT NULL,
	UNIQUE_KEY CHAR(1) NOT NULL,
	constraint UNIQUE_KEY_UN unique (UNIQUE_KEY)
) ENGINE=InnoDB;

INSERT INTO BATCH_JOB_EXECUTION_SEQ (ID, UNIQUE_KEY) select * from (select 0 as ID, '0' as UNIQUE_KEY) as tmp where not exists(select * from BATCH_JOB_EXECUTION_SEQ);

CREATE TABLE BATCH_JOB_SEQ (
	ID BIGINT NOT NULL,
	UNIQUE_KEY CHAR(1) NOT NULL,
	constraint UNIQUE_KEY_UN unique (UNIQUE_KEY)
) ENGINE=InnoDB;

INSERT INTO BATCH_JOB_SEQ (ID, UNIQUE_KEY) select * from (select 0 as ID, '0' as UNIQUE_KEY) as tmp where not exists(select * from BATCH_JOB_SEQ);

```

application.yml 파일에서 자동 생성 설정을 할 수 있다.
batch.jdbc.initialize-schema


5. 테이블
    - BATCH_JOB_INSTANCE
        - JobInstance 관련 정보를 가지고 있다.
    - BATCH_JOB_EXECUTION_PARAMS
        - JobParameter 관련 정보를 저장한다.
    - BATCH_JOB_EXECUTION  
        - JobExecution과 관련된 정보를 저장한다. 잡이 실행될 때마다 새로운 JobExecution이 생성된다. 
    - BATCH_JOB_EXECUTION_CONTEXT
        - JobExecution마다 하나의 JobExecution을 가지고있다. 
        - Job이 실행되는 동안 상태정보를 저장한다.
        - Step간 공유할 수 있다.
    
    - BATCH_STEP_EXECUTION
        - Step의 실행 정보가 저장된다.
    - BATCH_STEP_EXECUTION_CONTEXT
        - Step의 실행동안 여러 상태 정보를 저장한다.
        - Step 간 공유 불가능하다. 